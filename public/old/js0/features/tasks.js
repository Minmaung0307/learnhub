import { el, toast } from '../services/ui.js'; import { getFirebase } from '../services/firebase.js'; import { onAuth } from '../services/auth.js';
export async function viewTasks(){ const app=document.getElementById('app'); app.innerHTML=''; const user=await new Promise(r=>onAuth(r)); if(!user){ app.append(el('p',{},'Please login.')); return; }
  app.append(el('h2',{},'Tasks')); const board=el('div',{class:'board'}); const lanes=['todo','inprogress','done']; const laneEls={}; lanes.forEach(k=>{ const l=el('div',{class:'lane','data-lane':k},[el('h3',{},k.toUpperCase()),el('div',{class:'list'})]); board.append(l); laneEls[k]=l.querySelector('.list');}); app.append(board);
  const bar=el('div',{class:'kbar mt-2'},[ el('input',{id:'task-title',placeholder:'New task titleâ€¦',style:'width:260px'}), el('button',{class:'btn primary',onclick:()=>createTask()},'Add') ]); app.append(bar);
  const {db,collection,query,where,getDocs,doc,setDoc,deleteDoc,serverTimestamp,writeBatch}=await getFirebase();
  async function purgeDone(){ const q=await getDocs(query(collection(db,'tasks'),where('uid','==',user.uid),where('status','==','done'))); const now=Date.now(); for(const d of q.docs){ const t=d.data(); if(t.completedAt && (now-t.completedAt)>2*24*3600*1000){ await deleteDoc(doc(db,'tasks',d.id)); } } }
  async function load(){ await purgeDone(); const q=await getDocs(query(collection(db,'tasks'),where('uid','==',user.uid))); lanes.forEach(k=>laneEls[k].innerHTML=''); q.forEach(d=> laneEls[d.data().status||'todo'].append(taskItem(d.id,d.data()))); bindDnD(); }
  function taskItem(id,t){ return el('div',{class:'task',draggable:true,'data-id':id},[ el('div',{},t.title||'Untitled'), el('div',{class:'row gap mt-2'},[ el('button',{class:'btn',onclick:()=>editTask(id,t)},'Edit'), el('button',{class:'btn ghost',onclick:()=>delTask(id)},'Delete') ]) ]); }
  async function createTask(){ const title=document.getElementById('task-title').value.trim(); if(!title) return; const id=crypto.randomUUID(); await setDoc(doc(db,'tasks',id),{uid:user.uid,title,status:'todo',createdAt:serverTimestamp()}); document.getElementById('task-title').value=''; load(); }
  async function editTask(id,t){ const title=prompt('Edit title',t.title||''); if(!title) return; await setDoc(doc(db,'tasks',id),{title},{merge:true}); load(); }
  async function delTask(id){ if(!confirm('Delete this task?')) return; await deleteDoc(doc(db,'tasks',id)); load(); }
  function bindDnD(){ document.querySelectorAll('.task').forEach(card=>{ card.addEventListener('dragstart',()=>card.classList.add('dragging')); card.addEventListener('dragend',async()=>{ card.classList.remove('dragging'); const lane=card.closest('.lane')?.dataset.lane||'todo'; const id=card.dataset.id; const patch=lane==='done'?{status:lane,completedAt:Date.now()}:{status:lane,completedAt:null}; await setDoc(doc(db,'tasks',id),patch,{merge:true}); }); }); document.querySelectorAll('.lane').forEach(zone=>{ zone.addEventListener('dragover',e=>{e.preventDefault(); zone.classList.add('drop');}); zone.addEventListener('dragleave',()=>zone.classList.remove('drop')); zone.addEventListener('drop',e=>{e.preventDefault(); zone.classList.remove('drop'); const card=document.querySelector('.task.dragging'); if(card) zone.querySelector('.list').append(card);}); }); }
  load().catch(e=>toast(e.message,'bad')); }